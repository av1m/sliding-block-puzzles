# coding: utf-8
"""
This module is used to display the statistics of a protocol
Run protocol.py before running this module
"""

from __future__ import annotations

import itertools
import pickle


def show_report_statistic(filename: str) -> None:
    """Allows to see a statistical report of the protocol generated by the protocol.py module

    :param filename: Corresponds to the pickle file generated by protocol.py
    :type filename: str
    :return: just print in the console
    :rtype: None
    """
    # Retrieving the report generated by protocol.py
    report: list = pickle.load(open(filename, "rb"))

    # Group by strategy
    strategies: dict[str, list] = {
        k: [v for v in report if v["strategy"] == k]
        for k, val in itertools.groupby(report, lambda x: x["strategy"])
    }

    # Puzzle size
    print(f"Puzzle size (N) = {report[0]['n']}")

    for k, v in strategies.items():
        len_v_solved: int = sum(1 for k in v if k["is_solved"])
        print(f"\n--- {k} ---")

        # Number of solved
        print(f"Solved = {(len_v_solved / len(v)) * 100}")

        # init all variables
        (
            memories,
            times,
            avg_cost,
            gap_misplaced,
            gap_manhattan,
            gap_linear_conflicts,
            avg_len_solution,
        ) = [0] * 7

        for r in v:
            if not r["is_solved"]:
                continue

            # Memory complexity
            memories += r["complexity_memory"]
            # Time complexity
            times += r["generated_nodes"]
            # Average cost
            avg_cost += r["cost"]
            # Heuristic misplaced
            gap_misplaced += r["cost"] - r["heuristic_misplaced"]
            # Heuristic manhattan
            gap_manhattan += r["cost"] - r["heuristic_manhattan"]
            # Heuristic Linear Conflicts
            gap_linear_conflicts += r["cost"] - r["heuristic_linear_conflicts"]
            # Average of len(solution)
            avg_len_solution += r["len_solution"]

        print(f"Heuristic misplaced = {gap_misplaced}")
        print(f"Heuristic manhattan = {gap_manhattan}")
        print(f"Heuristic Linear Conflicts = {gap_linear_conflicts}")
        if len_v_solved > 0:  # prevent ZeroDivisionError
            print(f"Complexity memory = {memories / len_v_solved}")
            print(f"Time complexity = {times / len_v_solved}")
            print(f"Average cost = {avg_cost / len_v_solved}")
            print(f"Average of len(solution) = {avg_len_solution / len_v_solved}")
