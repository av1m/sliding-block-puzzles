# coding: utf-8
from abc import ABC, abstractmethod

from .puzzle import Puzzle


class Heuristic(ABC):
    """
    Interface allowing the use of heuristics on Puzzle
    The purpose of this interface is to allow the implementation of different heuristics
    To write an heuristic, just implement this class and override the compute method
    """

    @staticmethod
    @abstractmethod
    def compute(puzzle: Puzzle) -> float:
        """solving method used that attempts to provide a workable solution to solving a Puzzle

        As a reminder:

        - the heuristic must have an estimated cost >= 0
        - if n is a goal state, the heuristic must return 0.
        - the heuristic should never overestimate the cost to reach the goal state

        :param puzzle: puzzle in which we want to apply the heuristic
        :type puzzle: Puzzle
        :return: the estimation (number) generated by the heuristic
        :rtype: float
        """
        ...


class HeuristicMisplaced(Heuristic):
    def __repr__(self):
        return "Misplaced Heuristic"

    @staticmethod
    def compute(puzzle: Puzzle) -> float:
        """Counts the number of misplaced tiles
        We look at the goal state and compare it with our current puzzle.
        We count each tile that is not in its correct location

        :param puzzle: puzzle in which we want to apply the heuristic
        :type puzzle: Puzzle
        :return: the number of misplaced tiles
        :rtype: float
        """
        return sum(
            puzzle.get_cost(i, j, add_current_cost=False)
            for i in range(len(puzzle))
            for j in range(len(puzzle))
            if puzzle.tiles[i][j] != puzzle.GOAL_STATE[i][j]
        )


class HeuristicManhattan(Heuristic):
    def __repr__(self):
        return "Manhattan Distance Heuristic"

    @staticmethod
    def compute(puzzle: Puzzle) -> float:
        """Counts how much is a tile misplaced from the original position

        :param puzzle: puzzle in which we want to apply the heuristic
        :type: Puzzle
        :return: the distance that indicates how far the tiles are moved from their original position
        :rtype: float
        """

        def _get_distance(i: int, j: int) -> float:
            """Allows to know the distance of a tile from its desired location (goal state)

            We look::

            - the index of the tile (i, j) in the goal puzzle
            - the index of the tile (i1, j1) in the current puzzle

            Then, we calculate the distance: |i - i1| + |j - j1|

            :param i: line of the tile for which we are looking for the distance
            :type i: int
            :param j: column of the tile for which we are looking for the distance
            :type i: int
            :return: the distance between the current tile and the goal state tile
            :rtype: float
            """
            i1, j1 = puzzle.get_index(puzzle.tiles[i][j], puzzle.GOAL_STATE)
            distance = abs(i - i1) + abs(j - j1)
            return distance * puzzle.get_cost(i, j, add_current_cost=False)

        return sum(
            _get_distance(i, j) for i in range(len(puzzle)) for j in range(len(puzzle))
        )
